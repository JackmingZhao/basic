插入排序：
	直接插入排序：将一个数字插入到有序的序列里。
	时间复杂度：
		平准：O(n^2) 最好：O(n) 最坏：O(n^2)
	空间复杂度：
		O(l)
	稳定性：稳定排序
	
	Shell排序：创建一个步进，根据步进分成几个组，将每个组进行排序。然后步进每次缩小，直至等于1。  
	时间复杂度：
		平准：O(n^1.3) 最好：O(n) 最坏：O(n^2)
	空间复杂度：
		O(l)
	稳定性：不稳定排序
选择排序
	直接选择排序：每一次循环选出一个最值，然后第二次选出次值，以此类推。也可以每次找到一个最小的和最大的。
	时间复杂度：
		平准：O(n^2) 最好：O(n^2) 最坏：O(n^2)
	空间复杂度：
		O(l)
	稳定性：不稳定排序
	
	堆排序：利用内存的最大堆的原理，即每个二叉树堆的堆顶都是这棵树的最大值。每次循环构建这个堆，然后取出最大值与数列最后一个值交换。
	时间复杂度：
		平准：O(nlog(2)n) 最好：O(nlog(2)n) 最坏：O(nlog(2)n)
	空间复杂度：
		O(l)
	稳定性：不稳定排序
	
交换排序
	冒泡排序：对还未排好序的数列进行相邻两个数字的比较和调整，每当相邻的数比较后与要求相反时，就交换。
	时间复杂度：
		平准：O(n^2) 最好：O(n) 最坏：O(n^2)
	空间复杂度：
		O(l)
	稳定性：稳定排序
	
	快速排序：利用分治法，随机选取一个基数，分成一部分比这个基数大的，一部分比这个基数小的，迭代这个过程。
	时间复杂度：
		平准：O(nlog(2)n) 最好：O(nlog(2)n) 最坏：O(n^2)
	空间复杂度：
		O(nlog(2)n)
	稳定性：不稳定排序
	
归并排序：分治法的一种思想，将数组分成若干个数组，然后将每个数组排序之后再合并成一个数组。拆分工程使用递归，递归之后再合并，所以归并排序。
	时间复杂度：
		平准：O(nlog(2)n) 最好：O(nlog(2)n) 最坏：O(n^2)
	空间复杂度：
		O(n)
	稳定性：稳定排序
	
基数排序：从个位起，按0-9个数将这一组数据分成10个桶，然后是十位，然后是百位....每个位排序之后，将没有下一位的数字的位数直接取0。
	时间复杂度：
		平准：O(d(r+n)) 最好：O(d(n+rd)) 最坏：O(d(r+n))
	空间复杂度：
		O(rd+n)
	稳定性：稳定排序
	

平方阶（O(n^2)）排序
	直接插入、冒泡、直接选择
线性对数阶（O(nlog2n))排序
	快速排序、堆排序、归并排序
O(n^(1+$))排序，$介于0和1之间的常熟
	shell排序
线性阶（O(n)）排序
	基数排序
	
总结：
当原表有序或基本有序时，直接插入排序和冒泡排序大大减少交换次数和移动次数，时间复杂度可降至O(n)；
而快速排序则相反，当表基本有序时，就兑换为冒泡排序，时间复杂度提高为O(n^2)；
原表是否有序，对简单选择排序，堆排序，归并排序，和基数排序影响不大。

当n交大时，则应采用时间复杂度为O(nlog(2)n)的排序方法：快速排序、堆排序、归并排序
快速排序：待排序关键字是随机分布的，快速排序时间最短
堆排序：内存空间允许且要求稳定的
归并排序：有一定数据量移动，可能如插入排序组合效果好点

当n交大，内存空间允许，且要求稳定性--使用归并排序

当n交小时，可采用直接插入排序或直接选择排序
直接插入排序，当序列分布有序，直接插入排序将大大减少比较次数和移动记录次数
直接选择排序，如果序列分布有序，不要求稳定性，选择直接选择排序

一般不使用传统的冒泡排序

